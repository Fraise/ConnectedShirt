/* SLIP communication functions */
#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdio.h>

#include "serial.h"
#include "slip.h"

/* Sends a packet of length len */
void slip_send_packet(unsigned char *p, int len) {
	cli();
	send_serial(END); // send END char to flush data in receiver

	while (len--) { // for each byte, send the appropriate sequence
		switch (*p) {
			/* if it's the same code as an END character, we send a special */
			/* two character code so as not to make the receiver think we sent an END */
			case END:
				send_serial(ESC);
				send_serial(ESC_END);
				break;

			/* if it's the same code as an END character, we send a special */
			/* two character code so as not to make the receiver think we sent an END */
			case ESC:
				send_serial(ESC);
				send_serial(ESC_ESC);
				break;

			/* otherwise, we just send the character */
			default:
				send_serial(*p);
		}
		p++;
	}
	/* tell the receiver that we're done sending the packet */
	send_serial(END);
	sei();
}

 /* RECV_PACKET: receives a packet into the buffer located at "p". */
int slip_recv_packet(unsigned char *p, int len) {
	unsigned char c;
	int en_interrupt = 1, received = 0;
	/* sit in a loop reading bytes until we put together a whole packet. */
	/* Make sure not to copy them into the packet if we run out of room. */
	while (1) {
		/* get a character to process */
		c = get_serial();
		/* handle bytestuffing if necessary */
		switch (c) {
			/* if it's an END character then we're done with the packet */
			case END:
			   /* a minor optimization: if there is no data in the packet,
				*  ignore it. This is meant to avoid bothering IP with all the
				* empty packets generated by the duplicate END characters
				* which are in turn sent to try to detect line noise. */
				if (en_interrupt == 0) { en_interrupt = 1; sei(); }
				if (received) return received;
				else break;

			/* if it's the same code as an ESC character, wait and get another character
			 * and then figure out what to store in the packet based on that. */
			case ESC:
				c = get_serial();
				if (c == ESC_END)
					c = END;
				else if (c == ESC_ESC)
					c = ESC;
				/* if "c" is not one of these two, then we have a protocol violation.  The best
				 * bet seems to be to leave the byte alone and just stuff it into the packet. */

			/* here we fall into the default handler and let it store the character for us */
			default:
				if (en_interrupt == 1) { en_interrupt = 0; cli(); }
				if (received < len) p[received++] = c;
		}
	}
}
